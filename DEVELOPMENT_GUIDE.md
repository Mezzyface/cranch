# Development Guide - Living Document

## How We Work Together

### Our Development Process
When implementing features, we follow this pattern:
1. **You request a feature/change**
2. **I provide implementation steps in this document**
3. **You follow along and implement**
4. **We update the architecture documentation as we go**

This document serves as:
- A living reference of your game's architecture
- A place for step-by-step implementation guides
- Documentation of signal flow and connections

---

## Current Game Architecture

### Signal Flow Map

```
[Main Menu] --click start--> [Game Scene] --emits--> game_started
                                   |
                                   v
                            [SignalBus]
                                   |
                    +--------------+-------------+
                    |                            |
                    v                            v
            [GameManager]                 [UI Components]
            initialize_new_game()         (Debug Popup, HUD, etc)
                    |
                    v
            Creates PlayerData
            Creates Starter Creature
                    |
                    v
            Emits: player_data_initialized
                   creature_added
                   gold_changed
```

### Active Signal Connections

#### SignalBus Signals
```gdscript
# Game Flow
game_started â†’ GameManager.initialize_new_game()
player_data_initialized â†’ game_scene._on_player_data_ready()

# Save/Load
game_saved â†’ [Not connected yet]
game_loaded â†’ [Not connected yet]
save_failed â†’ [Not connected yet]

# Player & Resources
gold_changed(amount) â†’ [Not connected yet]
creature_added(creature) â†’ game_scene._on_creature_added()
creature_stats_changed(creature) â†’ [Not connected yet]

# Game Progress
week_advanced(week) â†’ FacilityManager.process_all_activities()

# Activity & Facility
activity_started(creature, activity) â†’ [Not connected yet]
activity_completed(creature, activity) â†’ [Not connected yet]
creature_species_changed(creature) â†’ [Not connected yet]
facility_assigned(creature, facility) â†’ FacilityManager.register_assignment()
facility_unassigned(creature, facility) â†’ FacilityManager.unregister_assignment()

# UI Events
show_debug_popup_requested â†’ [Not connected yet]
show_creature_details_requested(creature) â†’ [Not connected yet]
popup_closed(popup_name) â†’ [Not connected yet]
```

### System Overview

#### Autoload Order (Important!)
1. `GlobalEnums` - Game enumerations and constants
2. `SignalBus` - Central signal hub
3. `GameManager` - Game state management
4. `SaveManager` - Save/load operations

#### Core Systems

**GameManager**
- Manages PlayerData (gold, creatures)
- Handles game initialization
- Controls week progression
- Emits state changes through SignalBus
- Contains `facility_manager` instance (FacilityManager)

**FacilityManager** (accessed via `GameManager.facility_manager`)
- Tracks creature-to-facility assignments
- Processes all activities on week advancement
- Handles registration/unregistration of creatures
- Dictionary: `{facility: [creatures]}`
- Created and managed by GameManager

**SignalBus**
- Central hub for all signals
- No logic, just signal definitions
- Enables decoupled communication

**SaveManager**
- Handles all game persistence
- Resource-based saves at `user://savegame.tres`
- F5 to save, F9 to load
- Save metadata and versioning

**PlayerData Resource**
- Contains: gold, creatures array
- Persistent data structure

**CreatureData Resource**
- Contains: name, species, strength, agility, intelligence
- Individual creature stats

**DragDropComponent**
- Unified component for all drag/drop interactions
- Supports multiple drag types (CREATURE, FACILITY_CARD, CUSTOM)
- Configurable flags: `can_drag`, `can_accept_drops`
- Custom validation via callbacks
- Visual preview generation
- Signal-based communication (`drag_started`, `drag_ended`, `drop_received`)

---

## Implementation Steps Section

### ðŸŽ¯ Current Task: Bug Fixes - Activity Execution & Creature Duplication

**Bug 1: Facility activities don't modify stats**
- Activities show "Running activity" but don't execute
- Root cause: Using base `ActivityResource` class instead of specific activity subclasses

**Bug 2: Dragging creature between facility slots duplicates it**
- Same creature appears in multiple slots
- Root cause: Same-facility moves don't remove creature from original slot before adding to new slot

---

#### Fix 1: Use Proper Activity Classes in Facility Setup

**File:** `scenes/view/game_scene.gd`

**Problem:** Line 307 creates a base `ActivityResource` which has no implementation. The `run_activity()` method just shows a warning and does nothing.

**Solution:** Use the actual `StrengthTrainingActivity` class with preload.

Find `_place_test_facility_in_slot()` function (around line 294-318) and replace:

**OLD CODE (lines 307-310):**
```gdscript
# Add a strength training activity
var strength_activity = ActivityResource.new()
strength_activity.activity_name = "Strength Training"
strength_activity.description = "Gain +5 Strength"
```

**NEW CODE:**
```gdscript
# Add a strength training activity (use actual class, not base)
var strength_activity = preload("res://resources/activities/strength_training.gd").new()
strength_activity.strength_gain = 5  # Configure the stat gain
```

**Why:** Preloading the specific activity class ensures `run_activity()` has the actual implementation that modifies stats. The base class only shows warnings.

---

#### Fix 2: Handle Same-Facility Creature Moves (UPDATED)

**File:** `scenes/card/facility_card.gd`

**Problem:** The `elif source_node is AnimatedSprite2D:` is at the wrong indentation level. It should be inside the `if source_node:` block, not as an alternative to it. This means sprite removal never executes.

**Solution:** Change `elif` to `if` so both checks happen inside the source_node block.

Find `assign_creature_from_drag()` function (around line 136-147) and fix the indentation:

**CURRENT BROKEN CODE:**
```gdscript
# Handle removing from source
var source_node = drag_data.get("source_node")
if source_node:
	if source_node is CreatureDisplay:
		# From world - free the creature display
		source_node.queue_free()
elif source_node is AnimatedSprite2D:  # BUG: This is outside the if source_node block!
	# From facility (same or different) - use the facility_card reference in drag data
	var old_facility = drag_data.get("facility_card")
	if old_facility and old_facility is FacilityCard:
		# Remove from source facility (works for same facility too)
		old_facility.remove_creature_by_sprite(source_node)
```

**FIXED CODE:**
```gdscript
# Handle removing from source
var source_node = drag_data.get("source_node")
if source_node:
	if source_node is CreatureDisplay:
		# From world - free the creature display
		source_node.queue_free()
	elif source_node is AnimatedSprite2D:  # Now properly nested
		# From facility (same or different) - use the facility_card reference in drag data
		var old_facility = drag_data.get("facility_card")
		if old_facility and old_facility is FacilityCard:
			# Remove from source facility (works for same facility too)
			old_facility.remove_creature_by_sprite(source_node)
```

**Why:** The `elif` needs to be inside the `if source_node:` block so it can check if the source is an AnimatedSprite2D (from facility) vs CreatureDisplay (from world). Currently the sprite removal code never runs because it's unreachable.

---

### Testing Both Fixes

After implementing:
- [ ] Assign creature to facility slot
- [ ] Advance week using "Next Week" button
- [ ] Check console - should see "Squish gained 5 strength! (X -> Y)"
- [ ] Drag creature back to world and click to view stats
- [ ] Stats should show increased strength
- [ ] Drag creature from one facility slot to another slot in same facility
- [ ] Creature should move (not duplicate)
- [ ] Only one creature sprite should be visible


---

**Previous task completed:** Unified Drag and Drop System
- See `DRAG_DROP_CHANGES.md` for complete change log and documentation

---

## Completed Implementations

### âœ… Unified Drag & Drop Component System
**Architecture**: Layered Control nodes with z-indexing for proper input priority

**DragDropComponent Class** (`scripts/drag_drop_component.gd`):
- Reusable component for all drag/drop operations
- Extends Control, purely for interaction (no visual elements)
- **Drag Types**: CREATURE, FACILITY_CARD, CUSTOM
- **Configurable Flags**:
  - `can_drag`: Enable/disable drag initiation (drop-only zones use `false`)
  - `can_accept_drops`: Enable drop acceptance
  - `hide_on_drag`: Auto-hide source node during drag
- **Custom Validation**: `custom_can_drop_callback` for complex drop logic
- **Signals**: `drag_started`, `drag_ended`, `drop_received`

**Layered Architecture Pattern**:
All drag/drop uses z-indexed layers for proper input handling:
- **Layer 1 (z:100)**: Base drop zones (cover full area, drop-only)
- **Layer 2 (z:101-200)**: Individual drag sources (positioned over specific elements)

**Implementations**:
1. **Creatures in World**:
   - `CreatureDrag_[name]` components (z:200) as siblings to container
   - Follow creatures via global positioning in `_process()`
   - Separate from visual CreatureDisplay nodes

2. **Creature Container**:
   - `ContainerDropZone` (z:100) drop-only base layer
   - Accepts creatures from world or facilities
   - Repositions world creatures or spawns from facilities

3. **Facility Cards**:
   - `FacilityDrag` (z:100) for dragging card + accepting creature drops
   - `CreatureDrag_0`, `CreatureDrag_1` (z:101) per creature slot
   - All as direct children of FacilityCard for proper hierarchy

4. **Facility Slots**:
   - `FacilitySlotDropZone` (z:100) drop-only
   - Accepts facility card drops for placement/swapping

**Key Features**:
- Completely agnostic of visual elements (pure interaction layer)
- No native `_get_drag_data/_can_drop_data/_drop_data` in game code
- Proper mouse event propagation via z-index and child ordering
- Preview generation with customizable alpha
- Drop validation prevents overfilling facilities
- **See `DRAG_DROP_CHANGES.md` for migration documentation**

### âœ… Facility Cards with Drag & Drop
- Created FacilityCard UI scene and script
- Added drag functionality to creatures using Control child nodes
- Implemented drop detection on facility cards
- Visual feedback during drag (semi-transparent preview, highlighting)
- Creatures return to view if not dropped on facility
- CreatureContainer accepts drops for repositioning
- Automatic activity execution on assignment

### âœ… Facility & Activity System
- Created base ActivityResource class with overridable run_activity
- Created FacilityResource class managing multiple activities
- Example activities: StrengthTraining, SpeciesChange
- Activities can check conditions and modify creatures
- Signals for activity events in SignalBus
- Test facility setup in GameManager

### âœ… Game Initialization Flow
- Created PlayerData resource class
- Set up GameManager initialization
- Implemented SignalBus pattern
- Connected game_scene to show debug popup
- Added creature with species to starter data

### âœ… SignalBus Setup
- Created centralized signal definitions
- Added to autoload in correct order
- Connected game_started signal
- Connected player_data_initialized signal

### âœ… Creature Display System
- Spawning creatures in CreatureContainer
- Container boundary constraints with padding
- Idle/Walking state machine
- Directional animations (walk-up, walk-down, walk-left, walk-right)
- FacingDirection enum in GlobalEnums

### âœ… Emote Bubble System
- Random emote display above creatures
- 15 different emote types
- Timer-based with configurable intervals
- Pop-in animation with elastic tween
- Auto-cleanup after duration

### âœ… Save/Load System
- SaveManager singleton for all persistence
- Resource-based saves (SaveGame class)
- F5/F9 quick save/load
- Main menu continue button
- Save metadata and versioning
- Refactored from GameManager to dedicated SaveManager

---

## Quick Reference

### Common Patterns

#### Adding a New Signal
1. Define in `SignalBus`
2. Emit from source system
3. Connect in receiving systems
4. Update this document

#### Creating New UI Popup
1. Create scene in `scenes/windows/`
2. Create accompanying script
3. Connect to relevant SignalBus signals
4. Preload and instantiate from game_scene

#### Adding Game Features
1. Define needed signals in SignalBus
2. Implement logic in GameManager or appropriate system
3. Create UI components if needed
4. Wire up signal connections
5. Test the flow

#### Using DragDropComponent

**For Drag Sources** (things you can pick up):
```gdscript
var drag_component = DragDropComponent.new()
drag_component.name = "MyDrag"
drag_component.drag_type = DragDropComponent.DragType.CREATURE  # or FACILITY_CARD, CUSTOM
drag_component.drag_data_source = source_node  # The visual node being dragged
drag_component.mouse_filter_mode = Control.MOUSE_FILTER_STOP
drag_component.z_index = 101  # Above drop zones

# Position and size over the draggable element
drag_component.position = element_position
drag_component.size = element_size

# Connect signals
drag_component.drag_started.connect(func(data): pass)
drag_component.drag_ended.connect(func(successful): pass)

add_child(drag_component)
```

**For Drop Zones** (areas that accept drops):
```gdscript
var drop_zone = DragDropComponent.new()
drop_zone.name = "MyDropZone"
drop_zone.drag_type = DragDropComponent.DragType.CREATURE
drop_zone.can_accept_drops = true
drop_zone.can_drag = false  # Drop-only zone
drop_zone.mouse_filter_mode = Control.MOUSE_FILTER_STOP
drop_zone.z_index = 100  # Below drag sources

# Fill the droppable area
drop_zone.set_anchors_preset(Control.PRESET_FULL_RECT)
drop_zone.set_offsets_preset(Control.PRESET_FULL_RECT)

# Custom validation (optional)
drop_zone.custom_can_drop_callback = func(data: Dictionary) -> bool:
    return data.has("creature") and can_accept(data.creature)

# Connect drop signal
drop_zone.drop_received.connect(_on_drop_received)

add_child(drop_zone)
```

**Key Principles**:
- Drop zones at z:100, drag sources at z:101+
- Drop-only zones use `can_drag = false`
- Drag sources use `drag_data_source` to reference visual elements
- Components are siblings or parents to avoid mouse filter conflicts
- Use global positioning for components outside their parent's hierarchy

### File Structure
```
project/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ game_manager.gd (Game logic)
â”‚   â”œâ”€â”€ save_manager.gd (Persistence)
â”‚   â”œâ”€â”€ signal_bus.gd (Signal hub)
â”‚   â”œâ”€â”€ global_enums.gd (Constants)
â”‚   â””â”€â”€ managers/
â”‚       â””â”€â”€ facility_manager.gd (Facility assignments)
â”œâ”€â”€ resources/
â”‚   â”œâ”€â”€ creature_data.gd
â”‚   â”œâ”€â”€ player_data.gd
â”‚   â”œâ”€â”€ save_game.gd
â”‚   â”œâ”€â”€ facility_data.gd
â”‚   â””â”€â”€ activities/ (ActivityResource subclasses)
â”œâ”€â”€ scripts/
â”‚   â””â”€â”€ drag_drop_component.gd (Unified drag/drop)
â”œâ”€â”€ scenes/
â”‚   â”œâ”€â”€ view/ (Main scenes)
â”‚   â”‚   â”œâ”€â”€ main_menu.tscn/gd
â”‚   â”‚   â””â”€â”€ game_scene.tscn/gd
â”‚   â”œâ”€â”€ windows/ (Popups)
â”‚   â”‚   â”œâ”€â”€ debug_popup.tscn/gd
â”‚   â”‚   â””â”€â”€ emote_bubble.tscn/gd
â”‚   â”œâ”€â”€ card/ (Facility UI)
â”‚   â”‚   â”œâ”€â”€ facility_card.tscn/gd
â”‚   â”‚   â”œâ”€â”€ facility_slot.gd
â”‚   â”‚   â””â”€â”€ week_display.tscn/gd
â”‚   â””â”€â”€ entities/ (Game objects)
â”‚       â””â”€â”€ creature_display.tscn/gd
â””â”€â”€ assets/
    â”œâ”€â”€ sprites/creatures/
    â””â”€â”€ emotes/
```

---

## Notes for Future Development

**SignalBus Best Practices:**
- SignalBus pattern keeps systems decoupled
- Always emit signals with relevant data
- Check if data exists before emitting
- Remember to disconnect signals when nodes are freed

**DragDropComponent Best Practices:**
- Always use DragDropComponent for drag/drop (never native methods)
- Layer drop zones at z:100, drag sources at z:101+
- Use `can_drag = false` for drop-only zones
- Keep components separate from visual nodes
- Use global positioning for components outside parent hierarchy
- Clean up drag components when visual nodes are freed

**General Development:**
- Use preload() for scenes that will be instantiated multiple times
- Test drag/drop with different z-index configurations if issues arise
- Check mouse_filter settings if input isn't working as expected

---

## Next Possible Features

Potential implementations ready to guide:
- Week advancement system with UI
- Creature training mechanics
- Facility management
- Save/Load system
- Settings menu
- Creature detail view
- Resource management (gold spending)
- Activity system

*Request any feature and steps will appear in the Implementation Steps section above*